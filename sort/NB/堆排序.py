"""
堆排序：理解容易，代码超级难写，多体会体会
堆：一种特殊的完全二叉树
    大根堆：一棵完全二叉树，满足任意节点都比其孩子节点大
    小根堆：一棵完全二叉树，满足任意节点都比其孩子节点小
当前节点i的子节点：2 * i + 1
根据子节点i找到父节点：(i-1) // 2；小标是n-1的父节点：(i-1-1) // 2 = (i - 2) // 2
堆排序过程：
    1、建立一个堆
    2、得到堆顶元素，为最大元素
    3、去掉堆顶，将堆最后一个元素放到堆顶，此时可以通过一次调整重新使堆有序
    4、堆顶元素为次大元素
    5、重复3，知道堆变空
时间复杂度：因为每次只看2个子节点中的一个子节点，相当于折半，则o(logn)
"""


# 堆的调整函数
def sift(li, low, high):
    """
    :param li: 列表
    :param low: 堆顶位置（根节点）元素下标
    :param high: 堆的最后一个位置元素下标，作用：一个标识，判断j是否超了层数
    """
    # 最开始指向的根节点
    i = low
    # 开始是左子节点
    j = 2 * i + 1
    # 把堆顶存起来
    temp = li[low]
    # 只要j位置有数
    while j <= high:
        # 当具有左右子节点时，判断左右子节点大小
        if j + 1 <= high and li[j + 1] > li[j]:
            # j转而指向大的那个子节点
            j = j + 1
        # 如果子节点大于抽出的根节点，则将子节点移动到根节点上，子节点j处变为空位
        if li[j] > temp:
            li[i] = li[j]
            # 移动后，j处变成空位，让i指向这个空位，即i=j
            i = j
            # j指向下一层
            j = 2 * i + 1
        else:
            # 如果被抽出的元素temp大，则把temp放回到i处，即把temp放到当前堆的根节点处，循环结束
            li[i] = temp
            break
    else:
        # 当全部遍历完，没有子节点（i位于叶子节点，j跑出去了），把temp填回i处。
        li[i] = temp


def heap_sort(li: list):
    n = len(li)
    # 1、建堆
    # 从最后一个叶子结点所在的堆开始往上调整，需要根据子节点找到父节点，倒着遍历，一直到下标0
    for i in range((n - 2) // 2, -1, -1):
        # i表示建堆时候调整的堆的根节点下标
        # high的位置可以定义在整个列表二叉树的最后一个元素处，因为high的作用只是为了判断当前遍历层数是否超过了high，
        # 完全二叉树一旦某个带叶子的堆遍历时候超过了堆的层数，即j越界，那么j下标必然大于当前列表最后一个元素的下标
        sift(li, low=i, high=n - 1)
    # 2、得到堆顶元素，得到最大值
    # 3、抽出堆顶元素，将堆最后一个元素放到堆顶，此时可以通过一次调整重新使堆有序
    for i in range(n - 1, -1, -1):
        # i指向堆最后一个元素
        # 让堆顶与最后一个元素交换
        li[0], li[i] = li[i], li[0]
        # 调整去掉最后一个元素后剩下的堆：i-1是因为交换位置后，i尚未前移
        sift(li, 0, i - 1)
    # 上方执行完后，堆变空，此时已经排好序


"""
topK问题，取前k个最大的数
思路：取出列表前k个数，建立一个小根堆，列表剩下的元素都与堆顶元素比较，如果大于，则替换掉堆顶，并重新调整为小根堆
"""


def sift_low(li, low, high):
    """
    :param li: 列表
    :param low: 堆顶位置（根节点）元素下标
    :param high: 堆的最后一个位置元素下标，作用：一个标识，判断j是否超了层数
    """
    # 最开始指向的根节点
    i = low
    # 开始是左子节点
    j = 2 * i + 1
    # 把堆顶存起来
    temp = li[low]
    # 只要j位置有数
    while j <= high:
        # 当具有左右子节点时，判断左右子节点大小【小根堆为小于号】
        if j + 1 <= high and li[j + 1] < li[j]:
            # j转而指向大的那个子节点
            j = j + 1
        # 如果子节点大于抽出的根节点，则将子节点移动到根节点上，子节点j处变为空位【小根堆为小于号】
        if li[j] < temp:
            li[i] = li[j]
            # 移动后，j处变成空位，让i指向这个空位，即i=j
            i = j
            # j指向下一层
            j = 2 * i + 1
        else:
            # 如果被抽出的元素temp大，则把temp放回到i处，即把temp放到当前堆的根节点处，循环结束
            li[i] = temp
            break
    else:
        # 当全部遍历完，没有子节点（i位于叶子节点，j跑出去了），把temp填回i处。
        li[i] = temp


def topK(li, k):
    heap = li[0: k]
    for i in range((k - 2) // 2, -1, -1):
        sift_low(heap, i, k - 1)
    for i in range(k, len(li) - 1):
        if li[i] > heap[0]:
            heap[0] = li[i]
            sift_low(heap, 0, k - 1)
    # 遍历出数
    for i in range(k - 1, -1, -1):
        # i指向堆最后一个元素
        # 让堆顶与最后一个元素交换
        heap[0], heap[i] = heap[i], heap[0]
        # 调整去掉最后一个元素后剩下的堆：i-1是因为交换位置后，i尚未前移
        sift_low(li, 0, i - 1)
    return heap
