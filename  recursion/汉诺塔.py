"""
【汉诺塔问题】
n：盘子个数
a，b，c：把盘子从A经过B移动到C
初始：所有盘子在最左边，柱子从左到右分别编号A，B，C
分析
n=2时：
    小圆盘从A移动到C
    大圆盘从A移动到B
    小圆盘从C移动到B
n=n时：
    把上面n-1个盘子看成一个整体：
    1、n-1个盘子从A经过C移动到B，具体移动方法不管
    2、把最大的盘子（第n个盘子）从A移动到C
    3、把n-1个盘子从B经过A移动到C，具体移法不管
只有第二步移动一个盘子，其他均移动了n-1个盘子，此时转化为移动n-1个盘子的汉诺塔问题。
以此类推，每次递归都看做是比前一次递归少1个盘子的汉诺塔问题。不断缩小问题规模
"""
count = 0


def hanoi(n, a, b, c):
    """
    :param n: 盘子个数
    :param a: 从a
    :param b: 经过b
    :param c: 移动到c
    :return:
    递归终止条件：n <= 0
    """
    if n > 0:
        # 把最大盘子上方的n-1个盘子从A经过c移动到b
        global count
        count += 1
        hanoi(n - 1, a, c, b)
        # 把最大的盘子从A移动到C，这是个合法步骤，故可以打印出来
        print(f"moving from {a} to {c}")
        # 把n-1个盘子从B经过A移动到C
        hanoi(n - 1, b, a, c)


# 开始：目的是把3个盘子从A经过B移动到C
hanoi(5, "A", "B", "C")
print(count)
# 发现：前3次与后3为n=2时的步骤，第4次为n=1时的步骤
"""
总结：
    设n个盘子需要的步数为函数h(n)
    步骤数为：h(n) = h(n-1) + 1 + h(n-1) = 2 * h(n-1) + 1步
    根据数学推导，可以推出：h(n) = 2^n - 1 ≈ 2^n
"""
